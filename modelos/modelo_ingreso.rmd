---
title: "Modelo ingreso"
output: html_document
---

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=FALSE, eval=TRUE}
library(tidyverse)
library(rstan)
library(stats)
rm(list = ls())
```

## Datos a nivel hogar

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
base_ingreso_hog <- read_csv('../datos/base_hogar.csv')
```

En la muestra de la ENIGH se tienen observaciones a nivel hogar para 920 municipios, se le asigna un código consecutivo a estos municipios.

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
cat_mun <- as.data.frame(unique(base_ingreso_hog$ubica_geo))
names(cat_mun)[1] <- 'ubica_geo'
cat_mun <- cat_mun %>%
  mutate(geo_id = as.numeric(factor(cat_mun$ubica_geo))) %>%
  arrange(geo_id)
# guardar tabla con codificación de municipios
write_csv(x = cat_mun, path = '../datos/catalogo_mun.csv')
# inporporación de variable "geo_id"" a la tabla "base_ingreso_hog"
base_ingreso_hog <- inner_join(base_ingreso_hog, cat_mun, by = 'ubica_geo')
```

### Selección del conjunto de observaciones para entrenamiento del modelo y prueba.

Se seleccionan aleatoriamente el xx por ciento de los municipios que tienen muestra en la ENIGH, las observaciones a nivel hogar que pertenecen a los municipios seleccionados forman parte del conjunto de entrenamiento, el resto de observaciones a nivel hogar quedan en el conjunto de prueba. 

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
# selección de conjunto de entrenamiento
set.seed(12345)
muestra <- round(nrow(cat_mun) * 0.20, 0)
ind <- sample(c(1:nrow(cat_mun)), muestra)
base_ingreso_hog <- base_ingreso_hog %>%
  mutate(muestra = ifelse(geo_id %in% ind, 1, 0)) %>%
  arrange(desc(muestra))
rm('ind', 'muestra')
datos_entre_hog <- base_ingreso_hog %>%
  filter(muestra == 1)
```

Se integran los datos de las covariables a nivel hogar que se utilizarán en el modelo.

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
x_hogar <- model.matrix(~ - 1 + factor(tenen) + drenaje_1 + elect_1 + 
                              factor(combus) + eli_ba_1 + cua_coc_1 + 
                              excus_1 + vehi_1 + serv_comu_n + 
                              act_mayvalor_n + act_normal_n + equipa_n + 
                              cuart_n + tam_hog_n + hab_cuar_prom + 
                              hombres_n + mujeres_n + menores_n + 
                              p12_64_n + p65mas_n + ocup_n + 
                              pering_n + donativo_1 + remesas_1 + 
                              bene_gob_1 + j_sexo + j_edad + 
                              j_ed_formal + max_nved_h + hablaind_n + 
                              alfabe_n + ic_asalud_n + rezedu_may16_n + 
                              ins_ali_h + ic_cv_h + ic_sbv_h + 
                              rel_depen + tasa_mort + j_ocup + 
                              j_rezedu + j_hablaind + j_disc + 
                              j_ind + j_sub + j_sermed + 
                              j_agui + j_vac + j_utili + 
                              j_afore + j_sect + cony_sexo + 
                              cony_edad + cony_ed_formal + cony_ocup + 
                              cony_rezedu + cony_hablaind + cony_disc + 
                              cony_ind + cony_sub + cony_sermed + 
                              cony_agui + cony_vac + cony_utili + 
                              cony_afore + cony_sect + p16_menos_trab_n + 
                              p16_64_trab_n + p65mas_trab_n + jub_pen_n + 
                              factor(tam_loc), 
                              data = base_ingreso_hog)
nrow(x_hogar)
ncol(x_hogar)
```

Se integran los datos de las covariables a nivel hogar para el conjunto de entrenamiento que se utilizarán en el modelo.

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
x_hogar_entre <- model.matrix(~ - 1 + factor(tenen) + drenaje_1 + elect_1 + 
                              factor(combus) + eli_ba_1 + cua_coc_1 + 
                              excus_1 + vehi_1 + serv_comu_n + 
                              act_mayvalor_n + act_normal_n + equipa_n + 
                              cuart_n + tam_hog_n + hab_cuar_prom + 
                              hombres_n + mujeres_n + menores_n + 
                              p12_64_n + p65mas_n + ocup_n + 
                              pering_n + donativo_1 + remesas_1 + 
                              bene_gob_1 + j_sexo + j_edad + 
                              j_ed_formal + max_nved_h + hablaind_n + 
                              alfabe_n + ic_asalud_n + rezedu_may16_n + 
                              ins_ali_h + ic_cv_h + ic_sbv_h + 
                              rel_depen + tasa_mort + j_ocup + 
                              j_rezedu + j_hablaind + j_disc + 
                              j_ind + j_sub + j_sermed + 
                              j_agui + j_vac + j_utili + 
                              j_afore + j_sect + cony_sexo + 
                              cony_edad + cony_ed_formal + cony_ocup + 
                              cony_rezedu + cony_hablaind + cony_disc + 
                              cony_ind + cony_sub + cony_sermed + 
                              cony_agui + cony_vac + cony_utili + 
                              cony_afore + cony_sect + p16_menos_trab_n + 
                              p16_64_trab_n + p65mas_trab_n + jub_pen_n + 
                              factor(tam_loc), 
                              data = datos_entre_hog)
nrow(x_hogar_entre)
ncol(x_hogar_entre)
```

## Datos a nivel municipio

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
base_ingreso_mun <- read_csv('../datos/base_municipio.csv')
```

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
# se incorpora la variable "geo_id"" a la tabla "base_ingreso_mun"
base_ingreso_mun <- inner_join(base_ingreso_mun, cat_mun, by = 'ubica_geo')
base_ingreso_mun <- base_ingreso_mun %>%
  arrange(geo_id)
```

Se integran los datos de las covariables a nivel municipio que se utilizarán en el modelo.

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
x_mun <- model.matrix(~ -1 + per_med + uni_med + tasa_alf + ind_agu + ind_dre+
                      ind_ele + ind_des_hum + per_doc + esc_edu + uni_eco + 
                      factor(conapo),
                      data = base_ingreso_mun)
```

## Modelo

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
# preparar datos para el modelo
ingreso <- base_ingreso_hog$ingcor
ingreso_entre <- datos_entre_hog$ingcor
geo_id <- base_ingreso_hog$geo_id
geo_id_entre <- datos_entre_hog$geo_id
muestra <- base_ingreso_hog$muestra
datos_mod <- list(n = nrow(x_hogar_entre),
              n_mun = nrow(x_mun),
              mh = ncol(x_hogar_entre),
              mm = ncol(x_mun),
              ingreso = ingreso_entre,
              x_hogar = x_hogar_entre,
              x_municipio = x_mun,
              municipio = geo_id_entre,
              n_f = nrow(x_hogar),
              x_hogar_f = x_hogar,
              municipio_f = geo_id,
              in_sample = muestra)
```

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE, cache=TRUE}
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
mod_ingreso0 <- stan_model(file = '../modelos/mod_ingreso0.stan')
```

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE, cache=TRUE}
# correr el modelo
fit <- sampling(mod_ingreso0, data = datos_mod, iter = 1000, chains = 2, warmup = 250)
print(fit, pars = c('beta_0', 'beta', 'alpha'), digits = 1)
```

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=FALSE}
# extraer parámetros obtenidos con el modelo
ext_fit <- extract(fit)
#beta_mun_raw <- ext_fit$beta_mun_raw
#sigma_mun <- ext_fit$sigma_mun
#alpha_pos<- apply(ext_fit$alpha, 2, mean)
beta_mun <- apply(ext_fit$beta_mun, 2, mean)
beta_0 <- ext_fit$beta_0
beta_pos <- apply(ext_fit$beta, 2, mean)
sigma_pos <- ext_fit$sigma
log_reps <- apply(ext_fit$log_reps, 2, mean)

# función para estimar el ingreso
gen_quantities_r <- function(x_hogar, muni){
  #beta_mun <- sample(beta_mun_raw, 1) * sample(sigma_mun, 1) + sum(x_mun * alpha_pos)
  #beta_mun <- rnorm(1, 0, 1) * rnorm(1, 0, 1) + sum(x_mun * alpha_pos)
  reg_pred <- mean(beta_0) + sum(x_hogar * beta_pos) + beta_mun[muni]
  sigma_pred <- sample(sigma_pos, 1)
  log_ing <- rnorm(1, reg_pred, sigma_pred)
  return(log_ing)
}

# se obtienen las estimaciones del ingreso para el conjunto de prueba
set.seed(1234)
pred_log_ing <- rep(0, nrow(x_hogar)-nrow(x_hogar_entre)) 
for(i in (nrow(x_hogar_entre)+1):nrow(x_hogar)){
  muni <- base_ingreso_hog$geo_id[i]
  pred_log_ing[i] <- gen_quantities_r(x_hogar[i,], muni)
}

log_ingreso_test <- log(1 + base_ingreso_hog$ingcor[muestra == 0])
# error cuadrático medio
mean((pred_log_ing - log_ingreso_test)^2)
```

```{r, error=FALSE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}
post <- as.matrix(fit)
colnames(post)[1:20]
sel <- grep('log_reps', colnames(post))

# intervalos de confianza
ci90 <- matrix(NA, nrow = length(sel), ncol = 2)
for (i in 1:length(sel)) {
    ci90[i,] <- quantile(post[,sel[i]], prob = c(0.05, 0.95), names = FALSE)
}

# grafica
log_ingreso_entre <- log(1 + base_ingreso_hog$ingcor[muestra == 1])
plot(0, type= 'n', xlim = c(0,length(log_ingreso_entre)), ylim = range(log_ingreso_entre),
     xlab = 'hogar', ylab = 'ingreso', main = "")
t <- 1:nrow(datos_entre_hog)
polygon(c(rev(t), t), c(rev(ci90[,1]), ci90[,2]), col = 'green', border = FALSE)
lines(log_ingreso_entre, col = 'yellow', lwd = 2)
lines(1:nrow(datos_entre_hog), colMeans(post[,sel]), col = '#40D2FE', lwd = 2)
legend('bottomright', c('series', "pred (avg)", 'pred (50% CI)', 'pred (90% CI)'),
       col = c('#808080', '#40D2FE', '#FF668880', '#FF668830'),
       lwd = c(2,2,2))
```
